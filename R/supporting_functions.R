# Title: Supporting function for Marble
# Author: Mariana Castaneda Guzman
# Date created: 4/19/2023
# Date last updated: 4/19/2023

library(ggplot2)
library(RColorBrewer)

# The function plot_dbscan generates a scatter plot of the results of a DBSCAN
# clustering analysis performed on a dataset. The function takes as input the
# original dataset mod_data, the results of the clustering analysis mod, and the
# column indices for the ID, cluster, and label columns (id_col, cluster_col,
# and lable_col, respectively). The function first checks if the number of rows
# in the original dataset matches the number of rows in the clustering analysis
# and if the input data has more than two columns. If these conditions are met,
# the function generates a warning message. The function then renames the
# columns of the clustering analysis according to the input column indices and
# subsets the data to only include the first three columns. Next, the function
# converts the label column to a factor variable and assigns the label "core" to
# points classified as part of a core cluster, "border" to points classified as
# part of a border cluster, and "noise" to points classified as noise. The
# function then determines the number of unique clusters in the data and
# generates a color palette to assign to each cluster. If the number of clusters
# exceeds the number of colors available in the palette, the function increments
# the palette size using a linear interpolation of the palette colors. Finally,
# the function generates a scatter plot of the data using ggplot2, with the x
# and y axes corresponding to the first two columns of the input data and the
# point color and shape determined by the clustering analysis. The function
# returns the plot object generated by ggplot2.

plot_dbscan <- function(mod_data, mod, id_col = 1, cluster_col = 2, lable_col = 3){
  
  if (nrow(mod_data) != nrow(mod)) {
    stop("Error: The number of rows in 'mod_data' and 'mod' do not match. The data provided should be the same one used to trained the model.")
  }
  
  
  if (ncol(mod_data) > 2) {
    warning("The input data has more than two columns. Only the first two dimensions will be used for plotting.")
    mod_data <- mod_data[, 1:2]
    names(mod_data) <- c("x", "y")
  }
  
  
  if (!is.data.frame(mod)) {
    mod <- as.data.frame(mod)
  }
  
  if(ncol(mod) > 3){
    warning(paste0("The input data frame has more than three columns. Only the first three columns will be used for analysis. The expected column names are 'ID' for column ", id_col, ", 'cluster' for column ", cluster_col, ", and 'label' for column ", lable_col,". Please make sure your data is properly formatted."))
    mod <- mod[, 1:3]
  }
  
  names(mod)[id_col] <- "ID"
  names(mod)[cluster_col] <- "cluster"
  names(mod)[lable_col] <- "lable"
  
  warning(paste0("Using columns in training dataset in the following order: 'ID' for column ", id_col,
                 ", 'cluster' for column ", cluster_col, ", and 'label' for column ", lable_col,
                 ". Please make sure your data is properly formatted."))
  
  
  df <- cbind(mod_data, mod)
  
  head(df)
  
  df$lable <- ifelse(df$lable == 1, "core", "border")
  df$lable <- ifelse(df$cluster == 0, "noise",  df$lable)
  
  table(df$lable)
  
  num_clusters <- length(unique(df$cluster))
  
  colors <- brewer.pal(n = num_clusters, name = "Spectral")
  
  df$cluster <- as.factor(df$cluster)
  
  
  # If the number of clusters exceeds the maximum number of colors available in the palette,
  # increment the palette size using a linear interpolation of the palette colors.
  if (num_clusters > length(colors)) {
    colors <- colorRampPalette(colors)(num_clusters)
  }
  
  p <- ggplot(data = df, aes(x = x, y = y, color = cluster, shape = lable)) +
    geom_point(size = 3)+
    scale_color_manual(values = colors) +
    labs(title = "DBSCAN") +
    theme_bw() + theme(
      legend.key = element_rect(fill = "transparent", colour = "transparent"),
      legend.title = element_text(size = 15, family = "Times", face = "bold"),
      legend.text = element_text(size = 15, family = "Times"),
      
      plot.title = element_text(size = 15, family = "Times", face = "bold", 
                                hjust = 0.5),
      
      axis.title = element_text(size = 15, family = "Times", face = "bold"),
      axis.text = element_text(size = 15),
      axis.line.x = element_line(colour = "black", 
                                 linewidth = 1, linetype = "solid"),
      axis.line.y = element_line(colour = "black", 
                                 linewidth = 1, linetype = "solid"),
      
      panel.grid.major.x = element_blank(),
      panel.grid.major.y = element_line(color = "#b8b9ba"),
      panel.grid.minor.y = element_line(color = "#e1e2e3"),
      
      panel.background = element_blank()
    )
  
  p
  
  return(p)
}
